module;
#include <string>
#include <algorithm>
#include <ranges>
#include <array>
#include <format>

export module Brawler.CommandSignatureDefinitionSpecializationFileWriter;
import Brawler.I_SourceFileWriter;
import Brawler.FileWriterNode;
import Brawler.CommandSignatureID;
import Brawler.CommandSignatureBuilderCreators;
import Brawler.CommandSignatureDefinition;
import Brawler.FileStrings;
import Brawler.CommandSignatureBuilder;
import Util.General;

/*
[NOTE: Comments beginning with a "//" *ARE* written into the file, while those beginning with a "\\" are *NOT* written
into the file. The latter type of comments is used to describe implementation details.]

Source File Name: CommandSignatureDefinition_[Command Signature Identifier String].ixx

Contents:

// WARNING: This file was auto-generated by the Brawler Shader Compiler. You will incur the
// wrath of God if you dare touch it.

module;
#include <array>
#include "../DxDef.h"

export module Brawler.CommandSignatures.CommandSignatureDefinition:CommandSignatureDefinition_[CommandSignatureIdentifierString];
import :CommandSignatureDefinitionBase;
import Brawler.CommandSignatures.CommandSignatureID;
import Brawler.RootSignatures.RootSignatureID;

export namespace Brawler
{
	namespace CommandSignatures
	{
		template <>
		struct CommandSignatureDefinition<CommandSignatureID::[Command Signature Identifier String]>
		{
		private:
			\\ Here, a number of static constexpr D3D12_INDIRECT_ARGUMENT_DESC instances named INDIRECT_ARGUMENT_X
			\\ are defined, where X is the zero-based index of the indirect argument in the command signature.

			static constexpr std::array<D3D12_INDIRECT_ARGUMENT_DESC, X> INDIRECT_ARGUMENT_DESCRIPTION_ARR{
				\\ The INDIRECT_ARGUMENT_DESCRIPTION_ARR instance is initialized with all of the
				\\ INDIRECT_ARGUMENT_X instances in ascending order.
			};

		private:
			// Indirect arguments are tightly packed. This is specified directly in the MSDN:
			//
			// "The ordering of arguments within an indirect argument buffer is defined to exactly match the
			// order of arguments specified in the pArguments parameter of D3D12_COMMAND_SIGNATURE_DESC. All
			// of the arguments for one draw (graphics)/dispatch (compute) call within an indirect argument
			// buffer are tightly packed. However, applications are allowed to specify an arbitrary byte
			// stride between draw/dispatch commands in an indirect argument buffer."
			//
			// (Source: https://learn.microsoft.com/en-us/windows/win32/direct3d12/indirect-drawing#command-signature-creation)

#pragma pack(push)
#pragma pack(1)
			\\ Any custom struct definitions needed to define the command signature are added here, where packing
			\\ is disabled. This is in line with the indirect argument packing specifications described above.

			struct IndirectArgumentsLayout
			{
				\\ Each indirect argument is given a field in this struct in the order specified within
				\\ INDIRECT_ARGUMENT_DESCRIPTION_ARR. The exposed CommandSignatureType type alias can then be
				\\ used by calling classes to initialize indirect argument data on the CPU. This can be useful
				\\ for, e.g., making sure that counters are in a good (typically zeroed) state before shaders
				\\ can modify them.
				\\
				\\ Having the fields explicitly defined like this also makes for a nice reference when deciding
				\\ how to access/modify the indirect argument data in shaders. Just remember that indirect arguments
				\\ are tightly packed, so they won't always be usable in things like StructuredBuffers. (Adding
				\\ padding to the struct so that it could be used in StructuredBuffers would be highly dangerous,
				\\ since the D3D12 specifications let drivers assume that indirect arguments are located next to
				\\ each other in contiguous memory locations without regards to alignment.)
			};

		public:
			using CommandSignatureType = IndirectArgumentsLayout;

		public:
			static constexpr D3D12_COMMAND_SIGNATURE_DESC COMMAND_SIGNATURE_DESCRIPTION{
				.ByteStride = sizeof(CommandSignatureType),
				.NumArgumentDescs = static_cast<std::uint32_t>(INDIRECT_ARGUMENT_DESCRIPTION_ARR.size()),
				.pArgumentDescs = INDIRECT_ARGUMENT_DESCRIPTION_ARR.data()
			};

			// The MSVC really doesn't like it when static constexpr std::optional instances are used in C++20
			// modules. Instead, we use RootSignatures::RootSignatureID::COUNT_OR_ERROR to represent a command
			// signature which does not have an associated root signature.
			static constexpr RootSignatures::RootSignatureID ASSOCIATED_ROOT_SIGNATURE_ID = [...];
		};
	}
}
*/

export namespace Brawler
{
	namespace SourceFileWriters
	{
		template <CommandSignatureID CSIdentifier>
		class CommandSignatureDefinitionSpecializationFileWriter final : public I_SourceFileWriter
		{
		public:
			CommandSignatureDefinitionSpecializationFileWriter();

			CommandSignatureDefinitionSpecializationFileWriter(const CommandSignatureDefinitionSpecializationFileWriter& rhs) = delete;
			CommandSignatureDefinitionSpecializationFileWriter& operator=(const CommandSignatureDefinitionSpecializationFileWriter& rhs) = delete;

			CommandSignatureDefinitionSpecializationFileWriter(CommandSignatureDefinitionSpecializationFileWriter&& rhs) noexcept = default;
			CommandSignatureDefinitionSpecializationFileWriter& operator=(CommandSignatureDefinitionSpecializationFileWriter&& rhs) noexcept = default;

		protected:
			Brawler::FileWriterNode CreateFileWriterTree() const override;
		};
	}
}

// ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

namespace Brawler
{
	namespace SourceFileWriters
	{
		template <CommandSignatureID CSIdentifier>
		constexpr std::string CreateFileNameString()
		{
			constexpr std::string_view COMMAND_SIGNATURE_ID_STR{ Brawler::GetCommandSignatureIDString<CSIdentifier>() };

			std::string fileNameStr{ "CommandSignatureDefinition_" };
			fileNameStr += COMMAND_SIGNATURE_ID_STR;
			fileNameStr += ".ixx";

			return fileNameStr;
		}

		template <CommandSignatureID CSIdentifier>
		consteval auto CreateFileNameCharacterArray()
		{
			constexpr std::size_t FILE_NAME_STR_SIZE = CreateFileNameString<CSIdentifier>().size();

			// Add one to the size for the NUL-terminating character.
			std::array<char, FILE_NAME_STR_SIZE + 1> fileNameCharArr{};
			std::string fileNameStr{ CreateFileNameString<CSIdentifier>() };

			for (auto [destChar, srcChar] : std::views::zip(fileNameCharArr, fileNameStr))
				destChar = srcChar;

			return fileNameCharArr;
		}

		template <CommandSignatureID CSIdentifier>
		constexpr std::string CreateDefinitionBeginString()
		{
			constexpr std::string_view COMMAND_SIGNATURE_ID_STR{ Brawler::GetCommandSignatureIDString<CSIdentifier>() };

			std::string definitionBeginStr{
R"(module;
#include <array>
#include "../DxDef.h"

export module Brawler.CommandSignatures.CommandSignatureDefinition:CommandSignatureDefinition_)"
			};

			definitionBeginStr += COMMAND_SIGNATURE_ID_STR;

			definitionBeginStr +=
R"(;
import :CommandSignatureDefinitionBase;
import Brawler.CommandSignatures.CommandSignatureID;
import Brawler.RootSignatures.RootSignatureID;

export namespace Brawler
{
	namespace CommandSignatures
	{
)";

			return definitionBeginStr;
		}

		template <CommandSignatureID CSIdentifier>
		consteval auto CreateDefinitionBeginCharacterArray()
		{
			constexpr std::size_t DEFINITION_BEGIN_STR_SIZE = CreateDefinitionBeginString<CSIdentifier>().size();

			// Add one to the size for the NUL-terminating character.
			std::array<char, DEFINITION_BEGIN_STR_SIZE + 1> definitionBeginCharArr{};
			std::string definitionBeginStr{ CreateDefinitionBeginString<CSIdentifier>() };

			for (auto [destChar, srcChar] : std::views::zip(definitionBeginCharArr, definitionBeginStr))
				destChar = srcChar;

			return definitionBeginCharArr;
		}

		template <CommandSignatureID CSIdentifier>
		struct CommandSignatureStringInfo
		{
		private:
			static constexpr auto FILE_NAME_CHARACTER_ARR{ CreateFileNameCharacterArray<CSIdentifier>() };
			static constexpr auto DEFINITION_BEGIN_CHARACTER_ARR{ CreateDefinitionBeginCharacterArray<CSIdentifier>() };

		public:
			static constexpr std::string_view FILE_NAME_STR{ FILE_NAME_CHARACTER_ARR.data() };
			static constexpr std::string_view DEFINITION_BEGIN_STR{ DEFINITION_BEGIN_CHARACTER_ARR.data() };
		};
	}
}

namespace Brawler
{
	namespace SourceFileWriters
	{
		template <CommandSignatureID CSIdentifier>
		CommandSignatureDefinitionSpecializationFileWriter<CSIdentifier>::CommandSignatureDefinitionSpecializationFileWriter() :
			I_SourceFileWriter(Util::General::StringToWString(CommandSignatureStringInfo<CSIdentifier>::FILE_NAME_STR))
		{}

		template <CommandSignatureID CSIdentifier>
		Brawler::FileWriterNode CommandSignatureDefinitionSpecializationFileWriter<CSIdentifier>::CreateFileWriterTree() const
		{
			static constexpr std::string_view COMMAND_SIGNATURE_ID_STR{ Brawler::GetCommandSignatureIDString<CSIdentifier>() };
			
			FileWriterNode rootNode{};

			{
				FileWriterNode autoGeneratedWarningNode{};
				autoGeneratedWarningNode.SetOutputText(std::string{ Brawler::FileStrings::AUTO_GENERATED_WARNING_COMMENT });

				rootNode.AddChildNode(std::move(autoGeneratedWarningNode));
			}

			{
				FileWriterNode fileContentsNode{};

				{
					FileWriterNode definitionBeginNode{};
					definitionBeginNode.SetOutputText(std::string{ CommandSignatureStringInfo<CSIdentifier>::DEFINITION_BEGIN_STR });

					fileContentsNode.AddChildNode(std::move(definitionBeginNode));
				}

				{
					const CommandSignatures::CommandSignatureBuilder<CSIdentifier> cmdSignatureBuilder{ CommandSignatures::CreateCommandSignatureBuilder<CSIdentifier>() };
					fileContentsNode.AddChildNode(cmdSignatureBuilder.CreateCommandSignatureDefinitionFileWriterNode());
				}

				{
					static constexpr std::string_view DEFINITION_END_STR{
R"(	}
})"
					};

					FileWriterNode definitionEndNode{};
					definitionEndNode.SetOutputText(std::string{ DEFINITION_END_STR });

					fileContentsNode.AddChildNode(std::move(definitionEndNode));
				}

				rootNode.AddChildNode(std::move(fileContentsNode));
			}

			return rootNode;
		}
	}
}