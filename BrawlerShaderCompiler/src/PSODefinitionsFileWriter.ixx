module;
#include <string>

export module Brawler.PSODefinitionsFileWriter;
import Brawler.I_SourceFileWriter;
import Brawler.ShaderProfileID;
import Brawler.ShaderProfileDefinition;
import Brawler.FileWriterNode;
import Brawler.FileStrings;
import Brawler.PSOID;
import Brawler.JobSystem;
import Brawler.PSOBuilder;
import Brawler.PSOBuilderCreators;

/*
Source File Name: PSODefinition.ixx

Contents:

// WARNING: This file was auto-generated by the Brawler Shader Compiler. You will incur the
// wrath of God if you dare touch it.

module;
#include <array>
#include "DxDef.h"

export module Brawler.PSOs.PSODefinition;
import Brawler.PSOs.PSOID;
import Brawler.RootSignatures.RootSignatureID;
import Util.Engine;
import Brawler.D3D12.RootSignatureDatabase;
import Util.Reflection;

namespace Brawler
{
	namespace PSOs
	{
		template <Brawler::PSOID PSOIdentifier>
		struct PSODefinition
		{};

		template <>
		struct PSODefinition<PSOID::X>
		{
			struct PSOStreamType
			{
				\\ This will contain the contents of the PSO description stream used in ID3D12Device2::CreatePipelineState().
			};

			static constexpr std::array<std::uint8_t, sizeof(PSOStreamType)> DEFAULT_PSO_VALUE{...};
			static constexpr Brawler::RootSignatures::RootSignatureID ROOT_SIGNATURE_ID = {...};

			\\ Additional fields are added to this stucture as specified by the corresponding PSOBuilder's I_PSOFieldResolver
			\\ instances.

			static void ExecuteRuntimePSOResolution(PSOStreamType& psoDesc)
			{
				\\ This function's contents are filled out by the corresponding PSOBuilder's I_PSOFieldResolver instances.
			}
		};

		\\ This continues on for the rest of the required pipeline state objects.

		template <typename PSOStreamType, std::size_t FieldIndex>
		consteval bool IsComputePSOStream()
		{
			if constexpr (std::is_same_v<Util::Reflection::FieldType<PSOStreamType, FieldIndex>, CD3DX12_PIPELINE_STATE_STREAM_CS>)
				return true;

			if constexpr ((FieldIndex + 1) != Util::Reflection::GetFieldCount<PSOStreamType>())
				return IsComputePSOStream<PSOStreamType, (FieldIndex + 1)>();
			else
				return false;
		}
	}
}

export namespace Brawler
{
	namespace PSOs
	{
		enum class PipelineType
		{
			GRAPHICS,
			COMPUTE
		};

		template <Brawler::PSOs::PSOID PSOIdentifier>
		using PSOStreamType = PSODefinition<PSOIdentifier>::PSOStreamType;

		template <Brawler::PSOs::PSOID PSOIdentifier>
		consteval Brawler::RootSignatures::RootSignatureID GetRootSignatureID()
		{
			return PSODefinition<PSOIdentifier>::ROOT_SIGNATURE_ID;
		}

		template <Brawler::PSOs::PSOID PSOIdentifier>
		PSOStreamType<PSOIdentifier> CreatePSODescription()
		{
			// The contents of PSODefinition<PSOIdentifier>::DEFAULT_PSO_VALUE are the compile-time default
			// values of the PSO description serialized as a byte array.
			PSOStreamType<PSOIdentifier> psoDesc{ *(reinterpret_cast<const PSOStreamType<PSOIdentifier>*>(PSODefinition<PSOIdentifier>::DEFAULT_PSO_VALUE.data())) };

			// Resolve the remaining field of the PSO description which could not be filled out at compile
			// time.
			PSODefinition<PSOIdentifier>::ExecuteRuntimePSOResolution(psoDesc);

			return psoDesc;
		}

		template <Brawler::PSOs::PSOID PSOIdentifier>
		consteval PipelineType GetPipelineType()
		{
			return (IsComputePSOStream<PSOStreamType<PSOIdentifier>, 0>() ? PipelineType::COMPUTE : PipelineType::GRAPHICS);
		}
	}
}
*/

export namespace Brawler
{
	namespace SourceFileWriters
	{
		template <Brawler::ShaderProfiles::ShaderProfileID ProfileID>
		class PSODefinitionsFileWriter final : public I_SourceFileWriter
		{
		public:
			PSODefinitionsFileWriter();

			PSODefinitionsFileWriter(const PSODefinitionsFileWriter& rhs) = delete;
			PSODefinitionsFileWriter& operator=(const PSODefinitionsFileWriter& rhs) = delete;

			PSODefinitionsFileWriter(PSODefinitionsFileWriter&& rhs) noexcept = default;
			PSODefinitionsFileWriter& operator=(PSODefinitionsFileWriter&& rhs) noexcept = default;

		protected:
			Brawler::FileWriterNode CreateFileWriterTree() const override;
		};
	}
}

// -------------------------------------------------------------------------------------------------------------

namespace
{
	template <Brawler::PSOID PSOIdentifier>
	static void AddPSODefinitionJob(std::vector<Brawler::FileWriterNode>& nodeArr, Brawler::JobGroup& jobGroup, std::size_t& currIndex)
	{
		Brawler::FileWriterNode& currNode{ nodeArr[currIndex++] };

		jobGroup.AddJob([&currNode] ()
		{
			Brawler::PSOs::PSOBuilder<PSOIdentifier> psoBuilder{ Brawler::PSOs::CreatePSOBuilder<PSOIdentifier>() };
			currNode = psoBuilder.CreatePSODefinitionFileWriterNode();
		});
	}

	template <std::underlying_type_t<Brawler::PSOID>... PSOIdentifierNums>
	Brawler::FileWriterNode CreatePSODefinitionInstantiationsNode(std::integer_sequence<std::underlying_type_t<Brawler::PSOID>, PSOIdentifierNums...> psoSequence)
	{
		Brawler::FileWriterNode rootDefinitionsNode{};

		Brawler::JobGroup psoDefinitionInstantiationsJobGroup{};
		psoDefinitionInstantiationsJobGroup.Reserve(psoSequence.size());

		std::vector<Brawler::FileWriterNode> psoDefinitionNodeArr{};
		psoDefinitionNodeArr.resize(psoSequence.size());

		// Create a CPU job to instantiate every PSODefinition.
		std::size_t nodeArrIndex = 0;

		((AddPSODefinitionJob<static_cast<Brawler::PSOID>(PSOIdentifierNums)>(psoDefinitionNodeArr, psoDefinitionInstantiationsJobGroup, nodeArrIndex)), ...);
		psoDefinitionInstantiationsJobGroup.ExecuteJobs();

		for (auto&& childNode : psoDefinitionNodeArr)
			rootDefinitionsNode.AddChildNode(std::move(childNode));

		return rootDefinitionsNode;
	}
}

namespace Brawler
{
	namespace SourceFileWriters
	{
		template <Brawler::ShaderProfiles::ShaderProfileID ProfileID>
		PSODefinitionsFileWriter<ProfileID>::PSODefinitionsFileWriter() :
			I_SourceFileWriter(L"PSODefinition.ixx")
		{}

		template <Brawler::ShaderProfiles::ShaderProfileID ProfileID>
		Brawler::FileWriterNode PSODefinitionsFileWriter<ProfileID>::CreateFileWriterTree() const
		{
			Brawler::FileWriterNode rootNode{};

			{
				Brawler::FileWriterNode headerNode{};

				std::string headerStr{ Brawler::FileStrings::AUTO_GENERATED_WARNING_COMMENT };
				headerStr += "module;\n#include <array>\n#include \"DxDef.h\"\n\nexport module Brawler.PSOs.PSODefinition;\nimport Brawler.PSOs.PSOID;\nimport Brawler.RootSignatures.RootSignatureID;\nimport Util.Engine;\nimport Brawler.D3D12.RootSignatureDatabase;\nimport Util.Reflection;\n\n";

				headerNode.SetOutputText(std::move(headerStr));
				rootNode.AddChildNode(std::move(headerNode));
			}

			{
				Brawler::FileWriterNode internalNamespaceNode{};

				{
					Brawler::FileWriterNode beginInternalNamespaceNode{};
					beginInternalNamespaceNode.SetOutputText("namespace Brawler\n{\n\tnamespace PSOs\n\t{\n");

					internalNamespaceNode.AddChildNode(std::move(beginInternalNamespaceNode));
				}

				{
					Brawler::FileWriterNode defaultPSODefinitionNode{};
					defaultPSODefinitionNode.SetOutputText("\t\ttemplate <Brawler::PSOs::PSOID PSOIdentifier>\n\t\tstruct PSODefinition\n\t\t{};\n");

					internalNamespaceNode.AddChildNode(std::move(defaultPSODefinitionNode));
				}

				internalNamespaceNode.AddChildNode(CreatePSODefinitionInstantiationsNode(Brawler::ShaderProfiles::GetPSOIdentifiers<ProfileID>()));

				{
					Brawler::FileWriterNode isComputePSOStreamSubObjectNode{};
					isComputePSOStreamSubObjectNode.SetOutputText("\n\t\ttemplate <typename PSOStreamType, std::size_t FieldIndex>\n\t\tconsteval bool IsComputePSOStream()\n\t\t{\n\t\t\tif constexpr (std::is_same_v<Util::Reflection::FieldType<PSOStreamType, FieldIndex>, CD3DX12_PIPELINE_STATE_STREAM_CS>)\n\t\t\t\treturn true;\n\n\t\t\tif constexpr ((FieldIndex + 1) != Util::Reflection::GetFieldCount<PSOStreamType>())\n\t\t\t\treturn IsComputePSOStream<PSOStreamType, (FieldIndex + 1)>();\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n");

					internalNamespaceNode.AddChildNode(std::move(isComputePSOStreamSubObjectNode));
				}

				{
					Brawler::FileWriterNode endInternalNamespaceNode{};
					endInternalNamespaceNode.SetOutputText("\t}\n}\n\n");

					internalNamespaceNode.AddChildNode(std::move(endInternalNamespaceNode));
				}

				rootNode.AddChildNode(std::move(internalNamespaceNode));
			}

			{
				Brawler::FileWriterNode exportedNamespaceNode{};

				{
					Brawler::FileWriterNode beginExportedNamespaceNode{};
					beginExportedNamespaceNode.SetOutputText("export namespace Brawler\n{\n\tnamespace PSOs\n\t{\n");

					exportedNamespaceNode.AddChildNode(std::move(beginExportedNamespaceNode));
				}

				{
					Brawler::FileWriterNode pipelineTypeNode{};
					pipelineTypeNode.SetOutputText("\t\tenum class PipelineType\n\t\t{\n\t\t\tGRAPHICS,\n\t\t\tCOMPUTE\n\t\t};\n\n");

					exportedNamespaceNode.AddChildNode(std::move(pipelineTypeNode));
				}

				{
					Brawler::FileWriterNode psoStreamTypeNode{};
					psoStreamTypeNode.SetOutputText("\t\ttemplate <Brawler::PSOs::PSOID PSOIdentifier>\n\t\tusing PSOStreamType = PSODefinition<PSOIdentifier>::PSOStreamType;\n\n");

					exportedNamespaceNode.AddChildNode(std::move(psoStreamTypeNode));
				}

				{
					Brawler::FileWriterNode getRootSignatureIDNode{};
					getRootSignatureIDNode.SetOutputText("\t\ttemplate <Brawler::PSOs::PSOID PSOIdentifier>\n\t\tconsteval Brawler::RootSignatures::RootSignatureID GetRootSignature()\n\t\t{\n\t\t\treturn PSODefinition<PSOIdentifier>::ROOT_SIGNATURE_ID;\n\t\t}\n\n");

					exportedNamespaceNode.AddChildNode(std::move(getRootSignatureIDNode));
				}

				{
					// We could write this std::string using one raw C string (and, for performance reasons, perhaps we
					// should), but I wanted to segment it to explain what each part is doing.

					std::string createPSODescriptionStr{ "\t\ttemplate <Brawler::PSOs::PSOID PSOIdentifier>\n\t\tPSOStreamType<PSOIdentifier> CreatePSODescription()\n\t\t{\n" };

					// Initialize the PSO description from the byte array stored in the PSODefinition. We add a comment
					// explaining why the reinterpret_cast is okay.
					createPSODescriptionStr += "\t\t\t// The contents of PSODefinition<PSOIdentifier>::DEFAULT_PSO_VALUE are the compile-time default\n\t\t\t// values of the PSO description serialized as a byte array.\n\t\t\tPSOStreamType<PSOIdentifier> psoDesc{ *(reinterpret_cast<const PSOStreamType<PSOIdentifier>*>(PSODefinition<PSOIdentifier>::DEFAULT_PSO_VALUE.data())) };\n\n";

					// Resolve the remaining portions of the PSO description at runtime. This includes doing things like setting
					// the pRootSignature field to a created ID3D12RootSignature object. We add a comment explaining why
					// this step is necessary.
					createPSODescriptionStr += "\t\t\t// Resolve the remaining fields of the PSO description which could not be filled out at compile\n\t\t\t// time.\n\t\t\tPSODefinition<PSOIdentifier>::ExecuteRuntimePSOResolution(psoDesc);\n\n";

					createPSODescriptionStr += "\t\t\treturn psoDesc;\n\t\t}\n\n";

					Brawler::FileWriterNode createPSODescriptionNode{};
					createPSODescriptionNode.SetOutputText(std::move(createPSODescriptionStr));

					exportedNamespaceNode.AddChildNode(std::move(createPSODescriptionNode));
				}

				{
					Brawler::FileWriterNode getPipelineTypeNode{};
					getPipelineTypeNode.SetOutputText("\t\ttemplate <Brawler::PSOs::PSOID PSOIdentifier>\n\t\tconsteval PipelineType GetPipelineType()\n\t\t{\n\t\t\treturn (IsComputePSOStream<PSOStreamType<PSOIdentifier>, 0>() ? PipelineType::COMPUTE : PipelineType::GRAPHICS);\n\t\t}\n");

					exportedNamespaceNode.AddChildNode(std::move(getPipelineTypeNode));
				}

				{
					Brawler::FileWriterNode endExportedNamespaceNode{};
					endExportedNamespaceNode.SetOutputText("\t}\n}");

					exportedNamespaceNode.AddChildNode(std::move(endExportedNamespaceNode));
				}

				rootNode.AddChildNode(std::move(exportedNamespaceNode));
			}

			return rootNode;
		}
	}
}