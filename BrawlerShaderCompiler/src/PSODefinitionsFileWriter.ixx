module;
#include <string>

export module Brawler.PSODefinitionsFileWriter;
import Brawler.I_SourceFileWriter;
import Brawler.ShaderProfileID;
import Brawler.ShaderProfileDefinition;
import Brawler.FileWriterNode;
import Brawler.FileStrings;
import Brawler.PSOID;
import Brawler.JobSystem;
import Brawler.PSOBuilder;
import Brawler.PSOBuilderCreators;
import Brawler.PSODefinition;

/*
Source File Name: PSODefinition.ixx

Contents:

// WARNING: This file was auto-generated by the Brawler Shader Compiler. You will incur the
// wrath of God if you dare touch it.

module;
#include "../DxDef.h"

export module Brawler.PSOs.PSODefinition;

import :PSODefinitionBase;

\\ Immediately after that, every module partition unit containing a specialization of
\\ the PSODefinition structure is also imported.

import Brawler.PSOs.PSOID;
import Brawler.RootSignatures.RootSignatureID;
import Util.Engine;
import Util.Reflection;
import Brawler.PSOs.PipelineType;

namespace Brawler
{
	namespace PSOs
	{
		template <typename PSOStreamType, std::size_t FieldIndex>
		consteval bool IsComputePSOStream()
		{
			if constexpr (std::is_same_v<Util::Reflection::FieldType<PSOStreamType, FieldIndex>, CD3DX12_PIPELINE_STATE_STREAM_CS>)
				return true;

			if constexpr ((FieldIndex + 1) != Util::Reflection::GetFieldCount<PSOStreamType>())
				return IsComputePSOStream<PSOStreamType, (FieldIndex + 1)>();
			else
				return false;
		}
	}
}

export namespace Brawler
{
	namespace PSOs
	{
		template <Brawler::PSOs::PSOID PSOIdentifier>
		using PSOStreamType = PSODefinition<PSOIdentifier>::PSOStreamType;

		template <Brawler::PSOs::PSOID PSOIdentifier>
		consteval Brawler::RootSignatures::RootSignatureID GetRootSignatureID()
		{
			return PSODefinition<PSOIdentifier>::ROOT_SIGNATURE_ID;
		}

		template <Brawler::PSOs::PSOID PSOIdentifier>
		PSOStreamType<PSOIdentifier> CreatePSODescription()
		{
			// The contents of PSODefinition<PSOIdentifier>::DEFAULT_PSO_VALUE are the compile-time default
			// values of the PSO description serialized as a byte array.
			PSOStreamType<PSOIdentifier> psoDesc{ *(reinterpret_cast<const PSOStreamType<PSOIdentifier>*>(PSODefinition<PSOIdentifier>::DEFAULT_PSO_VALUE.data())) };

			// Resolve the remaining field of the PSO description which could not be filled out at compile
			// time.
			PSODefinition<PSOIdentifier>::ExecuteRuntimePSOResolution(psoDesc);

			return psoDesc;
		}

		template <Brawler::PSOs::PSOID PSOIdentifier>
		consteval PipelineType GetPipelineType()
		{
			return (IsComputePSOStream<PSOStreamType<PSOIdentifier>, 0>() ? PipelineType::COMPUTE : PipelineType::GRAPHICS);
		}
	}
}
*/

export namespace Brawler
{
	namespace SourceFileWriters
	{
		template <Brawler::ShaderProfiles::ShaderProfileID ProfileID>
		class PSODefinitionsFileWriter final : public I_SourceFileWriter
		{
		public:
			PSODefinitionsFileWriter();

			PSODefinitionsFileWriter(const PSODefinitionsFileWriter& rhs) = delete;
			PSODefinitionsFileWriter& operator=(const PSODefinitionsFileWriter& rhs) = delete;

			PSODefinitionsFileWriter(PSODefinitionsFileWriter&& rhs) noexcept = default;
			PSODefinitionsFileWriter& operator=(PSODefinitionsFileWriter&& rhs) noexcept = default;

		protected:
			Brawler::FileWriterNode CreateFileWriterTree() const override;
		};
	}
}

// -------------------------------------------------------------------------------------------------------------

namespace
{
	template <Brawler::ShaderProfiles::ShaderProfileID ProfileID>
	Brawler::FileWriterNode CreatePSODefinitionSpecializationImportsNode()
	{
		Brawler::FileWriterNode rootImportsNode{};
		std::string importsText{ "import :PSODefinitionBase;\n" };

		static constexpr auto APPEND_IMPORT_LAMBDA = []<std::underlying_type_t<Brawler::PSOID>... PSOIdentifierNums>(std::string& importsStr, std::integer_sequence<std::underlying_type_t<Brawler::PSOID>, PSOIdentifierNums...> psoSequence)
		{
			((importsStr += std::string{ "import :" } + std::string{ Brawler::GetPSOIDString<static_cast<Brawler::PSOID>(PSOIdentifierNums)>() } + ";\n"), ...);
		};

		APPEND_IMPORT_LAMBDA(importsText, Brawler::ShaderProfiles::GetPSOIdentifiers<ProfileID>());

		importsText += "\n";
		rootImportsNode.SetOutputText(std::move(importsText));

		return rootImportsNode;
	}
}

namespace Brawler
{
	namespace SourceFileWriters
	{
		template <Brawler::ShaderProfiles::ShaderProfileID ProfileID>
		PSODefinitionsFileWriter<ProfileID>::PSODefinitionsFileWriter() :
			I_SourceFileWriter(L"PSODefinition.ixx")
		{}

		template <Brawler::ShaderProfiles::ShaderProfileID ProfileID>
		Brawler::FileWriterNode PSODefinitionsFileWriter<ProfileID>::CreateFileWriterTree() const
		{
			Brawler::FileWriterNode rootNode{};

			{
				Brawler::FileWriterNode headerNode{};

				{
					Brawler::FileWriterNode beginHeaderNode{};

					std::string beginHeaderStr{ Brawler::FileStrings::AUTO_GENERATED_WARNING_COMMENT };
					beginHeaderStr += "module;\n#include \"../DxDef.h\"\n\nexport module Brawler.PSOs.PSODefinition;\n\n";

					beginHeaderNode.SetOutputText(std::move(beginHeaderStr));
					headerNode.AddChildNode(std::move(beginHeaderNode));
				}

				headerNode.AddChildNode(CreatePSODefinitionSpecializationImportsNode<ProfileID>());

				{
					Brawler::FileWriterNode endHeaderNode{};
					endHeaderNode.SetOutputText("import Brawler.PSOs.PSOID;\nimport Brawler.RootSignatures.RootSignatureID;\nimport Util.Engine;\nimport Util.Reflection;\nimport Brawler.PSOs.PipelineType;\n\n");

					headerNode.AddChildNode(std::move(endHeaderNode));
				}

				rootNode.AddChildNode(std::move(headerNode));
			}

			{
				Brawler::FileWriterNode internalNamespaceNode{};

				{
					Brawler::FileWriterNode beginInternalNamespaceNode{};
					beginInternalNamespaceNode.SetOutputText("namespace Brawler\n{\n\tnamespace PSOs\n\t{\n");

					internalNamespaceNode.AddChildNode(std::move(beginInternalNamespaceNode));
				}

				{
					Brawler::FileWriterNode isComputePSOStreamSubObjectNode{};
					isComputePSOStreamSubObjectNode.SetOutputText("\t\ttemplate <typename PSOStreamType, std::size_t FieldIndex>\n\t\tconsteval bool IsComputePSOStream()\n\t\t{\n\t\t\tif constexpr (std::is_same_v<Util::Reflection::FieldType<PSOStreamType, FieldIndex>, CD3DX12_PIPELINE_STATE_STREAM_CS>)\n\t\t\t\treturn true;\n\n\t\t\tif constexpr ((FieldIndex + 1) != Util::Reflection::GetFieldCount<PSOStreamType>())\n\t\t\t\treturn IsComputePSOStream<PSOStreamType, (FieldIndex + 1)>();\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n");

					internalNamespaceNode.AddChildNode(std::move(isComputePSOStreamSubObjectNode));
				}

				{
					Brawler::FileWriterNode endInternalNamespaceNode{};
					endInternalNamespaceNode.SetOutputText("\t}\n}\n\n");

					internalNamespaceNode.AddChildNode(std::move(endInternalNamespaceNode));
				}

				rootNode.AddChildNode(std::move(internalNamespaceNode));
			}

			{
				Brawler::FileWriterNode exportedNamespaceNode{};

				{
					Brawler::FileWriterNode beginExportedNamespaceNode{};
					beginExportedNamespaceNode.SetOutputText("export namespace Brawler\n{\n\tnamespace PSOs\n\t{\n");

					exportedNamespaceNode.AddChildNode(std::move(beginExportedNamespaceNode));
				}

				{
					Brawler::FileWriterNode psoStreamTypeNode{};
					psoStreamTypeNode.SetOutputText("\t\ttemplate <Brawler::PSOs::PSOID PSOIdentifier>\n\t\tusing PSOStreamType = PSODefinition<PSOIdentifier>::PSOStreamType;\n\n");

					exportedNamespaceNode.AddChildNode(std::move(psoStreamTypeNode));
				}

				{
					Brawler::FileWriterNode getRootSignatureIDNode{};
					getRootSignatureIDNode.SetOutputText("\t\ttemplate <Brawler::PSOs::PSOID PSOIdentifier>\n\t\tconsteval Brawler::RootSignatures::RootSignatureID GetRootSignature()\n\t\t{\n\t\t\treturn PSODefinition<PSOIdentifier>::ROOT_SIGNATURE_ID;\n\t\t}\n\n");

					exportedNamespaceNode.AddChildNode(std::move(getRootSignatureIDNode));
				}

				{
					// We could write this std::string using one raw C string (and, for performance reasons, perhaps we
					// should), but I wanted to segment it to explain what each part is doing.

					std::string createPSODescriptionStr{ "\t\ttemplate <Brawler::PSOs::PSOID PSOIdentifier>\n\t\tPSOStreamType<PSOIdentifier> CreatePSODescription()\n\t\t{\n" };

					// Initialize the PSO description from the byte array stored in the PSODefinition. We add a comment
					// explaining why the reinterpret_cast is okay.
					createPSODescriptionStr += "\t\t\t// The contents of PSODefinition<PSOIdentifier>::DEFAULT_PSO_VALUE are the compile-time default\n\t\t\t// values of the PSO description serialized as a byte array.\n\t\t\tPSOStreamType<PSOIdentifier> psoDesc{ *(reinterpret_cast<const PSOStreamType<PSOIdentifier>*>(PSODefinition<PSOIdentifier>::DEFAULT_PSO_VALUE.data())) };\n\n";

					// Resolve the remaining portions of the PSO description at runtime. This includes doing things like setting
					// the pRootSignature field to a created ID3D12RootSignature object. We add a comment explaining why
					// this step is necessary.
					createPSODescriptionStr += "\t\t\t// Resolve the remaining fields of the PSO description which could not be filled out at compile\n\t\t\t// time.\n\t\t\tPSODefinition<PSOIdentifier>::ExecuteRuntimePSOResolution(psoDesc);\n\n";

					createPSODescriptionStr += "\t\t\treturn psoDesc;\n\t\t}\n\n";

					Brawler::FileWriterNode createPSODescriptionNode{};
					createPSODescriptionNode.SetOutputText(std::move(createPSODescriptionStr));

					exportedNamespaceNode.AddChildNode(std::move(createPSODescriptionNode));
				}

				{
					Brawler::FileWriterNode getPipelineTypeNode{};
					getPipelineTypeNode.SetOutputText("\t\ttemplate <Brawler::PSOs::PSOID PSOIdentifier>\n\t\tconsteval PipelineType GetPipelineType()\n\t\t{\n\t\t\treturn (IsComputePSOStream<PSOStreamType<PSOIdentifier>, 0>() ? PipelineType::COMPUTE : PipelineType::GRAPHICS);\n\t\t}\n");

					exportedNamespaceNode.AddChildNode(std::move(getPipelineTypeNode));
				}

				{
					Brawler::FileWriterNode endExportedNamespaceNode{};
					endExportedNamespaceNode.SetOutputText("\t}\n}");

					exportedNamespaceNode.AddChildNode(std::move(endExportedNamespaceNode));
				}

				rootNode.AddChildNode(std::move(exportedNamespaceNode));
			}

			return rootNode;
		}
	}
}