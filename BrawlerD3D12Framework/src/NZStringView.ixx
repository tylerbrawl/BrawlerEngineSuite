module;
#include <string>
#include <string_view>
#include <cassert>
#include <compare>

export module Brawler.NZStringView;

namespace Brawler
{
	template <typename CharT, typename Traits>
	class BasicNZStringView;
}

export namespace Brawler
{
	template <typename CharT, typename Traits = std::char_traits<CharT>>
	class BasicNZStringView final : private std::basic_string_view<CharT, Traits>
	{
	private:
		friend constexpr auto operator<=>(const BasicNZStringView lhs, const BasicNZStringView rhs) = default;

	public:
		constexpr BasicNZStringView() = default;

		constexpr BasicNZStringView(const BasicNZStringView& rhs) = default;
		constexpr BasicNZStringView& operator=(const BasicNZStringView& rhs) = default;

		constexpr BasicNZStringView(BasicNZStringView&& rhs) noexcept = default;
		constexpr BasicNZStringView& operator=(BasicNZStringView&& rhs) noexcept = default;

		// Use a consteval constructor for the C-string variant to (try to)
		// ensure that we are getting a string literal, since we know that those are
		// always null-terminated.
		consteval BasicNZStringView(const CharT* const cStr);

		template <typename Allocator>
		constexpr BasicNZStringView(const std::basic_string<CharT, Traits, Allocator>& str);

		template <typename T>
			requires std::is_same_v<std::decay_t<T>, std::basic_string_view<CharT, Traits>>
		constexpr BasicNZStringView(T strView) = delete;

		/// <summary>
		/// Returns a pointer to the C-string being viewed by this BasicNZStringView instance. Unlike
		/// std::basic_string_view::data(), the C-string returned by this function is guaranteed to
		/// be null-terminated.
		/// 
		/// The value returned by this function can also be used to construct a
		/// std::basic_string_view. This std::basic_string_view instance will also be null-terminated,
		/// unless some operation causes its view to no longer end at the character immediately preceding
		/// the NUL character.
		/// </summary>
		/// <returns>
		/// The function returns a pointer to the null-terminated C-string being viewed by this
		/// BasicNZStringView instance.
		/// </returns>
		constexpr const CharT* C_Str() const;
		
		constexpr std::size_t GetSize() const;
		constexpr bool Empty() const;

		constexpr const CharT& operator[](const std::size_t index) const;

		constexpr void RemovePrefix(const std::size_t numCharsToRemove);

		/// <summary>
		/// Creates a std::basic_string instance containing the sub-string generated by taking numChars
		/// characters from the string viewed by this BasicNZStringView instance, starting from
		/// offsetInChars characters from the beginning of the view. 
		/// 
		/// In order to maintain the null-termination guarantee, the returned value is a std::basic_string, 
		/// rather than a std::basic_string_view.
		/// </summary>
		/// <typeparam name="Allocator">
		/// - The allocator which the returned std::basic_string will use.
		/// </typeparam>
		/// <param name="offsetInChars">
		/// - The position of the first character in the newly created sub-string.
		/// </param>
		/// <param name="numChars">
		/// - The requested length of the sub-string. The actual sub-string length will be the minimum of
		///   numChars and (GetSize() - offsetInChars).
		/// </param>
		/// <returns>
		/// The function returns a std::basic_string instance containing the requested sub-string.
		/// </returns>
		template <typename Allocator = std::allocator<CharT>>
		constexpr std::basic_string<CharT, Traits, Allocator> SubStr(const std::size_t offsetInChars = 0, const std::size_t numChars = std::npos) const;
	};
}

// -----------------------------------------------------------------------------------------------------------------------

namespace Brawler
{
	template <typename CharT, typename Traits>
	consteval BasicNZStringView<CharT, Traits>::BasicNZStringView(const CharT* const cStr) :
		std::basic_string_view<CharT, Traits>(cStr)
	{}

	template <typename CharT, typename Traits>
	template <typename Allocator>
	constexpr BasicNZStringView<CharT, Traits>::BasicNZStringView(const std::basic_string<CharT, Traits, Allocator>& str) :
		std::basic_string_view<CharT, Traits>(str)
	{}

	template <typename CharT, typename Traits>
	constexpr const CharT* BasicNZStringView<CharT, Traits>::C_Str() const
	{
		return std::basic_string_view<CharT, Traits>::data();
	}

	template <typename CharT, typename Traits>
	constexpr std::size_t BasicNZStringView<CharT, Traits>::GetSize() const
	{
		return std::basic_string_view<CharT, Traits>::size();
	}

	template <typename CharT, typename Traits>
	constexpr bool BasicNZStringView<CharT, Traits>::Empty() const
	{
		return std::basic_string_view<CharT, Traits>::empty();
	}

	template <typename CharT, typename Traits>
	constexpr const CharT& BasicNZStringView<CharT, Traits>::operator[](const std::size_t index) const
	{
		assert(index < GetSize() && "ERROR: An out-of-bounds index was specified in a call to BasicNZStringView::operator[]()!");
		return std::basic_string_view<CharT, Traits>::operator[](index);
	}

	template <typename CharT, typename Traits>
	constexpr void BasicNZStringView<CharT, Traits>::RemovePrefix(const std::size_t numCharsToRemove)
	{
		assert(numCharsToRemove <= GetSize() && "ERROR: An invalid value was specified for the number of characters to remove in a call to BasicNZStringView::RemovePrefix()!");
		std::basic_string_view<CharT, Traits>::remove_prefix(numCharsToRemove);
	}

	template <typename CharT, typename Traits>
	template <typename Allocator>
	constexpr std::basic_string<CharT, Traits, Allocator> BasicNZStringView<CharT, Traits>::SubStr(const std::size_t offset, const std::size_t numChars) const
	{
		return std::basic_string<CharT, Traits, Allocator>{ std::basic_string_view<CharT, Traits>::substr(offset, numChars) };
	}
}

export namespace Brawler
{
	/// <summary>
	/// While std::string_view is great for easily accessing and performing operations on
	/// strings efficiently, one of its key drawbacks is that it does not guarantee that the
	/// strings which it views are actually null-terminated.
	/// 
	/// Brawler::BasicNZStringView is a class which attempts to remedy this by providing a
	/// subset of the features of std::string_view in order to guarantee that any
	/// Brawler::BasicNZStringView instance always refers to a null-terminated string. This
	/// can be necessary for, e.g., interacting with C-based APIs.
	/// 
	/// Brawler::BasicNZStringView has a constexpr constructor for std::string (because these
	/// are always null-terminated) and a consteval constructor for C-style strings (because
	/// string literals are always null-terminated, but the same cannot be said for raw C-style
	/// strings generated at runtime).
	/// 
	/// Brawler::NZStringView is the version of Brawler::BasicNZStringView which works for
	/// char strings.
	/// </summary>
	using NZStringView = BasicNZStringView<char, std::char_traits<char>>;

	/// <summary>
	/// While std::string_view is great for easily accessing and performing operations on
	/// strings efficiently, one of its key drawbacks is that it does not guarantee that the
	/// strings which it views are actually null-terminated.
	/// 
	/// Brawler::BasicNZStringView is a class which attempts to remedy this by providing a
	/// subset of the features of std::string_view in order to guarantee that any
	/// Brawler::BasicNZStringView instance always refers to a null-terminated string. This
	/// can be necessary for, e.g., interacting with C-based APIs.
	/// 
	/// Brawler::BasicNZStringView has a constexpr constructor for std::string (because these
	/// are always null-terminated) and a consteval constructor for C-style strings (because
	/// string literals are always null-terminated, but the same cannot be said for raw C-style
	/// strings generated at runtime).
	/// 
	/// Brawler::NZWStringView is the version of Brawler::BasicNZStringView which works for
	/// wchar_t strings. These are typically used for interacting with the Win32 API and not
	/// much else.
	/// </summary>
	using NZWStringView = BasicNZStringView<wchar_t, std::char_traits<wchar_t>>;
}