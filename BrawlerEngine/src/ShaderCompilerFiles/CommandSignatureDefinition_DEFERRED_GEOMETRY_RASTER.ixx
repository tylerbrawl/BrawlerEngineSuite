// WARNING: This file was auto-generated by the Brawler Shader Compiler. You will incur the
// wrath of God if you dare touch it.

module;
#include <array>
#include "../DxDef.h"

export module Brawler.CommandSignatures.CommandSignatureDefinition:CommandSignatureDefinition_DEFERRED_GEOMETRY_RASTER;
import :CommandSignatureDefinitionBase;
import Brawler.CommandSignatures.CommandSignatureID;
import Brawler.RootSignatures.RootSignatureID;

export namespace Brawler
{
	namespace CommandSignatures
	{
		template <>
		struct CommandSignatureDefinition<CommandSignatureID::DEFERRED_GEOMETRY_RASTER>
		{
		private:
			static constexpr D3D12_INDIRECT_ARGUMENT_DESC INDIRECT_ARGUMENT_0{
				.Type = D3D12_INDIRECT_ARGUMENT_TYPE::D3D12_INDIRECT_ARGUMENT_TYPE_DRAW
			};

			static constexpr std::array<D3D12_INDIRECT_ARGUMENT_DESC, 1> INDIRECT_ARGUMENT_DESCRIPTION_ARR{
				INDIRECT_ARGUMENT_0
			};

		private:
			// Indirect arguments are tightly packed. This is specified directly in the MSDN:
			//
			// "The ordering of arguments within an indirect argument buffer is defined to exactly match the
			// order of arguments specified in the pArguments parameter of D3D12_COMMAND_SIGNATURE_DESC. All
			// of the arguments for one draw (graphics)/dispatch (compute) call within an indirect argument
			// buffer are tightly packed. However, applications are allowed to specify an arbitrary byte
			// stride between draw/dispatch commands in an indirect argument buffer."
			//
			// (Source: https://learn.microsoft.com/en-us/windows/win32/direct3d12/indirect-drawing#command-signature-creation)

#pragma pack(push)
#pragma pack(1)
			struct IndirectArgumentsLayout
			{
				D3D12_DRAW_ARGUMENTS DrawArguments;
			};
#pragma pack(pop)

		public:
			using CommandSignatureType = IndirectArgumentsLayout;

		public:
			static constexpr D3D12_COMMAND_SIGNATURE_DESC COMMAND_SIGNATURE_DESCRIPTION{
				.ByteStride = sizeof(CommandSignatureType),
				.NumArgumentDescs = static_cast<std::uint32_t>(INDIRECT_ARGUMENT_DESCRIPTION_ARR.size()),
				.pArgumentDescs = INDIRECT_ARGUMENT_DESCRIPTION_ARR.data()
			};

			// The MSVC really doesn't like it when static constexpr std::optional instances are used in C++20
			// modules. Instead, we use RootSignatures::RootSignatureID::COUNT_OR_ERROR to represent a command
			// signature which does not have an associated root signature.
			static constexpr RootSignatures::RootSignatureID ASSOCIATED_ROOT_SIGNATURE_ID = RootSignatures::RootSignatureID::COUNT_OR_ERROR;
		};
	}
}