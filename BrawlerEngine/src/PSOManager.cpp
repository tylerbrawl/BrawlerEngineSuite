module;
#include <array>
#include <cassert>
#include "DxDef.h"

module Brawler.PSOManager;
import Brawler.PSOData;
import Brawler.JobSystem;
import Brawler.IMPL.PSODef;
import Brawler.IMPL.RootSignatureDef;
import Brawler.BPSReader;
import Brawler.BPSWriter;
import Util.Engine;
import Brawler.ConvenienceTypes;

namespace
{
	struct PSOCompilationResults
	{
		/// <summary>
		/// This is the compiled PSO which was generated by a call to [Anonymous Namespace]::CreatePipelineState().
		/// If the PSO could not be created, then this field will be nullptr; otherwise, the field has a valid
		/// value, and it refers to the compiled PSO.
		/// </summary>
		Microsoft::WRL::ComPtr<ID3D12PipelineState> PipelineState;

		/// <summary>
		/// If PipelineState != nullptr, then this field describes whether or not the PSO needs to be cached again.
		/// If PipelineState == nullptr, then the value of this field is undefined.
		/// </summary>
		bool PSORequiresCaching;
	};

	template <Brawler::PSOID ID>
	PSOCompilationResults CreatePipelineState(const Brawler::IMPL::PSOSubObjectStream<ID>& psoStream)
	{
		const bool isCachedPSOSpecified = (psoStream.CachedPSO.pCachedBlob != nullptr);
		const D3D12_PIPELINE_STATE_STREAM_DESC psoStreamDesc{
			.SizeInBytes = sizeof(psoStream),
			.pPipelineStateSubobjectStream = reinterpret_cast<void*>(&psoStream)
		};
		Microsoft::WRL::ComPtr<ID3D12PipelineState> pipelineState{ nullptr };

		// We need to check the returned HRESULT manually here.
		HRESULT hr = Util::Engine::GetD3D12Device().CreatePipelineState(&psoStreamDesc, IID_PPV_ARGS(&pipelineState));

		switch (hr)
		{
		case S_OK: [[likely]]
		{
			// If we were successful here, then we only need to cache the PSO again if
			// a cached PSO was not already specified.

			return PSOCompilationResults{
				.PipelineState = pipelineState,
				.PSORequiresCaching = !isCachedPSOSpecified
			};
		}
			
		case D3D12_ERROR_ADAPTER_NOT_FOUND: [[fallthrough]];
		case D3D12_ERROR_DRIVER_VERSION_MISMATCH:
		{
			// These error codes indicate that a cached PSO was provided, but that the
			// graphics device or its driver has changed since it was made. In this case,
			// we need to re-compile the PSO from scratch by removing the cached PSO from
			// the stream.

			psoStream.CachedPSO.pCachedBlob = nullptr;
			psoStream.CachedPSO.CachedBlobSizeInBytes = 0;

			break;
		}

		// We want to make sure that we are appropriately changing our PSO version numbers
		// as needed. In the deep, dark corners of the MSDN, it is said that if a cached PSO's
		// data does not match that specified by the rest of the PSO sub-object stream, then
		// E_INVALIDARG might be returned. We can use this to check if version numbers need
		// to be updated.

#ifdef _DEBUG
		case E_INVALIDARG:
		{
			assert(false && "ERROR: ID3D12Device2::CreatePipelineState() returned E_INVALIDARG! Did you update your PSO version numbers appropriately?");
			[[fallthrough]];
		}
#endif // _DEBUG

		default: [[unlikely]]
		{
			return PSOCompilationResults{
				.PipelineState = nullptr,
				.PSORequiresCaching = false
			};
		}
		}

		// If we get here, then we must have failed to compile the PSO with a cached PSO. In
		// that case, we try it again here.
		hr = Util::Engine::GetD3D12Device().CreatePipelineState(&psoStreamDesc, IID_PPV_ARGS(&pipelineState));

		assert(hr != E_INVALIDARG && "ERROR: ID3D12Device2::CreatePipelineState() returned E_INVALIDARG! Did you update your PSO version numbers appropriately?");

		return PSOCompilationResults{
			.PipelineState = (SUCCEEDED(hr) ? pipelineState : nullptr),
			.PSORequiresCaching = true
		};
	}

	template <Brawler::PSOID ID>
	Brawler::PSOData CreatePSOData()
	{
		Brawler::PSOData psoData{
			.PSO = nullptr,
			.RootSignature = Brawler::IMPL::GetSerializedRootSignature<Brawler::IMPL::GetPSORootSignatureID<ID>()>()
		};
		Brawler::IMPL::PSOSubObjectStream<ID> psoStream{ Brawler::IMPL::GetPSOSubObjectStream<ID>() };
		psoStream.RootSignature = psoData.RootSignature.Get();

		Brawler::BPSReader<ID> bpsReader{};
		bpsReader.AttemptPSOBlobExtraction();

		Microsoft::WRL::ComPtr<ID3DBlob> cachedPSOBlob = bpsReader.GetCachedPSOBlob();

		if (cachedPSOBlob != nullptr) [[likely]]
		{
			psoStream.CachedPSO.pCachedBlob = cachedPSOBlob->GetBufferPointer();
			psoStream.CachedPSO.CachedBlobSizeInBytes = cachedPSOBlob->GetBufferSize();
		}

		PSOCompilationResults buildResults{ CreatePipelineState<ID>(psoStream) };

		if (buildResults.PipelineState == nullptr) [[unlikely]]
			throw std::runtime_error{ "ERROR: A PSO failed to compile!" };

		psoData.PSO = buildResults.PipelineState;

		if (buildResults.PSORequiresCaching || bpsReader.IsBPSFileOutdated()) [[unlikely]]
		{
			Brawler::BPSWriter<ID> bpsWriter{ psoData };
			bpsWriter.WritePSODataToBPSFile();
		}

		return psoData;
	}

	static constexpr std::array<Brawler::FunctionPtr<Brawler::PSOData>, std::to_underlying(Brawler::PSOID::COUNT_OR_ERROR)> PSO_CREATION_FUNCTION_PTR_ARR{};
}

namespace Brawler
{
	PSOManager::PSOManager() :
		mPSODataMap()
	{}

	void PSOManager::Initialize()
	{
		// In the future, we may be able to make this asynchronous. One way to do this while
		// guaranteeing that only a constant number of threads N are ever compiling PSOs would
		// be to separate the elements of PSO_CREATION_FUNCTION_PTR_ARR into N equally-sized
		// arrays which are captured by one Brawler::Job each. Then, whichever thread takes
		// this Brawler::Job is responsible for compiling all of the PSOs in this array.
		//
		// However, for right now, PSO compilation is done synchronously. This is fine for
		// games with a relatively small number of PSOs, but it becomes annoying for games
		// which generate large numbers of shader permutations. Honestly, I wouldn't be
		// surprised if games like Doom Eternal completely neglect asynchronous PSO compilation.

		Brawler::JobGroup psoCompilationGroup{};
		psoCompilationGroup.Reserve(std::to_underlying(Brawler::PSOID::COUNT_OR_ERROR));

		for (std::underlying_type_t<Brawler::PSOID> i = 0; i < std::to_underlying(Brawler::PSOID::COUNT_OR_ERROR); ++i)
		{
			// This is thread-safe because mPSODataMap is actually a std::array,
			// and each thread will be writing into a separate location within
			// the array.
			Brawler::PSOData& psoData{ mPSODataMap[i] };
			const Brawler::FunctionPtr<Brawler::PSOData> psoCreationFunction{ PSO_CREATION_FUNCTION_PTR_ARR[i] };

			psoCompilationGroup.AddJob([&psoData, psoCreationFunction] ()
			{
				psoData = psoCreationFunction();
			});
		}

		psoCompilationGroup.ExecuteJobs();
	}

	ID3D12PipelineState& PSOManager::GetPipelineStateObject(const PSOID psoID)
	{
		return *(mPSODataMap[std::to_underlying(psoID)].PSO.Get());
	}

	ID3D12RootSignature& PSOManager::GetRootSignature(const PSOID psoID)
	{
		return *(mPSODataMap[std::to_underlying(psoID)].RootSignature.Get());
	}
}